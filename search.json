[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 bayesianTiterCalc authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/bayestitercalc.html","id":"simulated-data","dir":"Articles","previous_headings":"","what":"Simulated data","title":"bayesTiterCalc","text":"Using sample_dose_response function, simulate data 30 serum samples sample diluted 2-fold eight dilutions 1:8 1:1024. dilution four replicates. example, ’s assumed \\(\\phi\\) values drawn uniform distribution range (0.75 16) can described logistic function \\(\\) \\(b\\) values shown. data must long-format - see , use R’s ‘head’ function example data . function ‘sample_dose_response’ samples uniform distribution {, b} calls ‘simulate_dose_response’ function. Check simulated data non monotonic using non_monotonic function. expected mortality cell cultures increases higher serum dilutions. Non-monotonic data show ‘accidental’ death survival cell cultures dilution levels, .e., unexpected cell death low dilutions survival high dilutions. table output , ‘0’ ‘1’ represents monotonic non-monotonic data points, respectively. simulated data can plotted show number proportion replicates surviving cells (Y axis) per dilution: Fit mechanistic model simulated data. use Stan’s sampling algorithm, optimization algorithm also available ‘optimizing_stan’ function.","code":"ndraws = 30;  a = 1.65  b = 2.65  prior_phi <- list(lower = 0.75, upper = 16) dilutions <- 2^c(3, 4, 5, 6, 7, 8, 9, 10);  nreplicates_per_dilution = 2 simData <- sample_dose_response(ndraws, prior_phi, a, b, dilutions, nreplicates_per_dilution) library(dplyr)  non_monotone <- simData %>%   group_by(simData$draw) %>%   summarise(is_non_monotone = non_monotonic(simData$number_surviving))  table(non_monotone$is_non_monotone) library(ggplot2)  options(dplyr.summarise.inform = FALSE) simData %>%   filter(draw %in% 1:4) %>%   group_by(draw, dilution) %>%   summarise(outcome = number_surviving) %>%   ggplot(aes(x = dilution, y = outcome)) +     geom_point() +     scale_x_log10() +     ylim(0, max(simData$number_surviving)) +     labs(x = 'Dilution', y = 'Outcome') +     theme(axis.title = element_text(size = 8),           axis.text = element_text(size = 6),           strip.text = element_text(size = 6)) +     facet_wrap(~draw) stan_data = list(N = nrow(simData),                  nreplicates = rep(nreplicates_per_dilution, nrow(simData)),                  survival = simData$number_surviving,                  dilution = simData$dilution,                  nsample = max(simData$draw),                  sample = simData$draw,                  is_log = 1)  fit <- sampling_stan(standata = stan_data, chains = 4, iter = 1000, init = 'random') # extract model estimated phi values: phis <- apply(rstan::extract(fit, \"phi\")[[1]], 2, mean) phiEstimated <- data.frame('phi' = phis, 'dataset' = rep('Estimated', length(phis)))  # phi values in the simulated data: phiVals <- (simData[!duplicated(simData[,c('draw')]),'phiValue'])$phiValue phiSimulated <- data.frame('phi' = phiVals, 'dataset' = rep('Simulated', length(phiVals)))  # Compare phi values - in the simulated ('actual') data and estimated by the model: phiDF <- rbind(phiEstimated, phiSimulated) ggplot(phiDF, aes(phi, fill = dataset)) +   geom_density(alpha = 0.3) +   scale_fill_brewer(palette = 'Set1') +   labs(x = 'phi', y = 'density') +   theme_bw() # extract posterior predictive quantities: survival_sim <- rstan::extract(fit, \"survival_sim\")[[1]] outcome_sim <- apply(survival_sim, 2, function(x) quantile(x, 0.5)) prob <- apply(rstan::extract(fit, \"prob\")[[1]], 2, median) prob_low <- apply(rstan::extract(fit, \"prob\")[[1]], 2, function(x) quantile(x, 0.25)) prob_high <- apply(rstan::extract(fit, \"prob\")[[1]], 2, function(x) quantile(x, 0.75))"},{"path":"/articles/bayestitercalc.html","id":"reed-and-muench-serum-titration-data","dir":"Articles","previous_headings":"","what":"Reed and Muench serum titration data","title":"bayesTiterCalc","text":"Model fitting using Stan’s sampling algorithm. Examine model output:","code":"delayedAssign('df', reedmuenchTitrations) df <- df %>%   rename_all(tolower) %>%   mutate(sample = 1,          nreplicates = alive + dead,          survival = survival / 100,          type = \"real\",          lower = qbeta(0.025, 1 + alive, 1 + nreplicates - alive),          upper = qbeta(0.975, 1 + alive, 1 + nreplicates - alive))  # simulated dilutions lower <- log10(min(df$dilution) / 2) upper <- log10(max(df$dilution) * 2) ndilutionssim <- 50 dilutionssim <- 10^seq(lower, upper, length.out = ndilutionssim)  # Prepare data for model fitting stan_data <- list(   N = nrow(df),   nreplicates = df$nreplicates,   survival = df$alive,   dilution = df$dilution,   nsample = max(df$sample),   sample = df$sample,   is_log = 1,   ndilutionssim = ndilutionssim,   dilutionssim = dilutionssim ) fit <- sampling_rm(standata=stan_data, iter=2000, chains=4, init = 'random') print(fit, \"ed50\") #> Inference for Stan model: modelwithppc_reedmuench. #> 4 chains, each with iter=2000; warmup=1000; thin=1;  #> post-warmup draws per chain=1000, total post-warmup draws=4000. #>  #>       mean se_mean   sd  2.5%   25%   50%   75% 97.5% n_eff Rhat #> ed50 30.73    0.16 9.97 16.45 24.01 29.31 35.45 53.86  3673    1 #>  #> Samples were drawn using NUTS(diag_e) at Tue Nov 15 09:18:02 2022. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1). print(fit, \"phi\") #> Inference for Stan model: modelwithppc_reedmuench. #> 4 chains, each with iter=2000; warmup=1000; thin=1;  #> post-warmup draws per chain=1000, total post-warmup draws=4000. #>  #>     mean se_mean   sd 2.5%  25%  50%   75% 97.5% n_eff Rhat #> phi 8.28    0.11 4.09 2.88 5.32 7.43 10.33  18.6  1315    1 #>  #> Samples were drawn using NUTS(diag_e) at Tue Nov 15 09:18:02 2022. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1).  probs <- rstan::extract(fit, \"prob_survive\")[[1]] lower <- apply(probs, 2, function(x) quantile(x, 0.025)) upper <- apply(probs, 2, function(x) quantile(x, 0.975)) middle <- apply(probs, 2, function(x) quantile(x, 0.5))  df_both <- tibble(lower=lower, survival=middle, upper=upper, type=\"simulated\", dilution=dilutionssim) %>%   bind_rows(df)  # plot ggplot(data=filter(df_both, type==\"real\"), aes(x=dilution, y=survival)) +   geom_ribbon(data=filter(df_both, type==\"simulated\"), aes(ymin=lower, ymax=upper), fill=\"blue\", alpha=0.3) +   geom_line(data=filter(df_both, type==\"simulated\"), colour=\"black\", linetype=2) +   geom_pointrange(aes(ymin=lower, ymax=upper)) +   geom_point(data=tibble(dilution=26.9, survival=0.5), colour=\"orange\", shape=18, size=3) +   labs(x = \"Dilution\", y = \"Survival\") +   scale_y_continuous(labels=scales::percent) +   scale_x_log10() params <- rstan::extract(fit, c(\"phi\", \"a\", \"b\")) %>% as.data.frame() library(bayesplot) library(hexbin)  mcmc_pairs(fit, pars = c(\"phi\", \"a\", \"b\"), off_diag_fun = \"hex\")"},{"path":"/articles/bayestitercalc.html","id":"real-virus-neutralization-assay-data","dir":"Articles","previous_headings":"","what":"Real virus neutralization assay data","title":"bayesTiterCalc","text":"following example show use package actual serum neutralization data. data similar simulated data , .e., 2-fold serum dilutions 1:8 1:1024, dilution tested duplicate. Visualize data show number proportion replicates surviving cells (Y axis) per dilution:  Fit model data using sampling algorithm: Examine model estimates - \\(\\phi\\) ED50 - compare antibody titer calculated Reed Muench method. ED50 model generated quantity endpoint dilution 50% mortality, calculated : \\[ed50 = \\phi * \\exp(-) ^ {-1 / b}\\] Extract posterior predictive simulations: Plot probability cells surviving per serum dilution point:","code":"delayedAssign('df', evTitrations) df <- df %>% mutate(sample=as.numeric(as.factor(sampleID))) table(df$outcome) non_monotone <- df %>%   group_by(sample) %>%   summarise(is_non_monotone=non_monotonic(outcome))  table(non_monotone$is_non_monotone) df %>%   filter(sample %in% 1:4) %>%   group_by(sample, dilutions) %>%   summarise(outcome=mean(outcome) / 2) %>%   ggplot(aes(x=dilutions, y=outcome)) +     geom_point() +     scale_x_log10() +     labs(x = 'Dilutions', y = 'Outcome') +     theme(axis.title = element_text(size = 10),           axis.text = element_text(size = 8),           strip.text = element_text(size = 8)) +     facet_wrap(~sample) stan_data <- list(   N = nrow(df),   nreplicates=rep(2, nrow(df)),   survival=df$outcome,   dilution=df$dilutions,   nsample=max(df$sample),   sample=df$sample,   is_log=1 )  fit <- sampling_stan(standata = stan_data, chains=4, iter = 1000, init = 'random') phiEstimated <- apply(rstan::extract(fit, \"phi\")[[1]], 2, mean) ed50Estimated <- apply(rstan::extract(fit, \"ed50\")[[1]], 2, mean) phis_ed50_titers <- df  for(i in 1:nrow(phis_ed50_titers)){   phis_ed50_titers[i, 'phi'] <- phiEstimated[phis_ed50_titers$sample[i]];   phis_ed50_titers[i, 'ed50'] <- ed50Estimated[phis_ed50_titers$sample[i]] }  plot(log10(phis_ed50_titers$titer), phis_ed50_titers$phi,       main=\"Titer vs. phi\", ylab=\"phi\", xlab=\"log10 Titer\", pch=19) plot(log10(phis_ed50_titers$titer), phis_ed50_titers$ed50,       main=\"Titer vs. ED50\", ylab=\"ED50\", xlab=\"log10 Titer\", pch=19) plot(phis_ed50_titers$phi, phis_ed50_titers$ed50,       main=\"phi vs. ED50\", ylab=\"ED50\", xlab=\"phi\", pch=19) survival_sim <- rstan::extract(fit, \"survival_sim\")[[1]] outcome_sim <- apply(survival_sim, 2, function(x) quantile(x, 0.5)) prob <- apply(rstan::extract(fit, \"prob\")[[1]], 2, median) prob_low <- apply(rstan::extract(fit, \"prob\")[[1]], 2, function(x) quantile(x, 0.025)) prob_high <- apply(rstan::extract(fit, \"prob\")[[1]], 2, function(x) quantile(x, 0.975)) df <- df %>%    mutate(outcome_sim = outcome_sim, prob = prob, prob_low = prob_low, prob_high = prob_high) df_long <- df %>%    select(sampleID, dilutions, outcome, outcome_sim, prob, prob_low, prob_high) %>%    rename(actual = outcome, simulated = outcome_sim) %>%    mutate(fraction = actual / 2) bars <- df_long %>%    group_by(sampleID) %>%    summarise(barcode = paste0(actual, collapse = \"\")) %>%    ungroup() %>%    pull(barcode) %>%    unique() bars_lookup <- df_long %>%    group_by(sampleID) %>%    summarise(barcode = paste0(actual, collapse = \"\")) df_long <- df_long %>% left_join(bars_lookup) df_each_code <- df_long %>%    group_by(barcode) %>%    summarise(sampleID = first(sampleID)) %>%    mutate(keep = TRUE) df_short <- df_long %>%    left_join(df_each_code) %>%    filter(keep == TRUE) library(tidyverse) tmp <- df_short %>%    group_by(sampleID) %>%    summarise(first_non_total = which(actual < 2)[1]) %>%    mutate(first_non_total = ifelse(is.na(first_non_total),                                  max(first_non_total, na.rm = T) + 1,                                  first_non_total)) df_short %>%    left_join(tmp) %>%    mutate(sampleID = as.factor(sampleID)) %>%    mutate(sampleID = fct_reorder(sampleID, first_non_total)) %>%   ggplot(aes(x = dilutions, y = prob)) +     geom_ribbon(aes(ymin = prob_low, ymax = prob_high), alpha = 0.7, fill = \"blue\") +     geom_point(aes(y = fraction), size = 0.8, alpha = 0.7, colour = \"orange\") +     geom_line(aes(y = fraction), alpha = 0.7, colour = \"orange\") +     scale_color_brewer(\"Type\", palette = \"Dark2\") +     scale_x_log10() +     labs(y = \"Probability of survival\", x = \"Dilution\") +     theme(axis.title = element_text(size=8),           axis.text = element_text(size=6),           strip.text = element_text(size=6)) +     facet_wrap(~sampleID)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Everlyn Kamau. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kamau E (2022). bayesianTiterCalc: Bayesian calculation serum neutralization antibody titer. R package version 0.0.0.9000, https://github.com/ekamau/bayesianTiterCalc.","code":"@Manual{,   title = {bayesianTiterCalc: Bayesian calculation of serum neutralization antibody titer},   author = {Everlyn Kamau},   year = {2022},   note = {R package version 0.0.0.9000},   url = {https://github.com/ekamau/bayesianTiterCalc}, }"},{"path":"/index.html","id":"bayesiantitercalc","dir":"","previous_headings":"","what":"Bayesian calculation of serum neutralization antibody titer","title":"Bayesian calculation of serum neutralization antibody titer","text":"bayesianTiterCalc Bayesian inference method calculates serum sample’s antibody concentration, ϕ, titer based data standard virus neutralization assay. method uses dose-response relationship logistic function simulate mortality cell monolayers function antibody concentration. Given limited information per sample ’s inherent experimental design neutralization assays (number replicates per dilution number dilutions), advantage Bayesian inference use probability distributions incorporate uncertainty outcome.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bayesian calculation of serum neutralization antibody titer","text":"can install development version bayesianTiterCalc GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"ekamau/bayesianTiterCalc\")"},{"path":"/reference/bayesianTiterCalc-package.html","id":null,"dir":"Reference","previous_headings":"","what":"The 'bayesianTiterCalc' package. — bayesianTiterCalc-package","title":"The 'bayesianTiterCalc' package. — bayesianTiterCalc-package","text":"Bayesian calculation serum neutralization titer.","code":""},{"path":"/reference/bayesianTiterCalc-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The 'bayesianTiterCalc' package. — bayesianTiterCalc-package","text":"Stan Development Team (NA). RStan: R interface Stan. R package version 2.26.9. https://mc-stan.org","code":""},{"path":"/reference/evTitrations.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of serum neutralization data. — evTitrations","title":"Example of serum neutralization data. — evTitrations","text":"dataset containing output virus neutralization eight serum dilutions. data contains results 10 serum samples.","code":""},{"path":"/reference/evTitrations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of serum neutralization data. — evTitrations","text":"","code":"evTitrations"},{"path":"/reference/evTitrations.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of serum neutralization data. — evTitrations","text":"data frame 80 rows 9 variables sampleID sample ID Age Age individual Year Year sample collection titer Antibody titer calculated conventionally rep1 Outcome assay first replicate, '1' alive, '0' dead rep2 Outcome assay second replicate, '1' alive, '0' dead outcome sum rep 1 rep2 dilutions serum dilution, per sample","code":""},{"path":"/reference/evTitrations.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example of serum neutralization data. — evTitrations","text":"Data generated using method described https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8386771/","code":""},{"path":"/reference/logistic.html","id":null,"dir":"Reference","previous_headings":"","what":"logistic function — logistic","title":"logistic function — logistic","text":"logistic function","code":""},{"path":"/reference/logistic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"logistic function — logistic","text":"","code":"logistic(concentration, a, b)"},{"path":"/reference/logistic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"logistic function — logistic","text":"concentration Estimate model Estimate model b Estimate model","code":""},{"path":"/reference/logistic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"logistic function — logistic","text":"numeric value","code":""},{"path":"/reference/logistic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"logistic function — logistic","text":"","code":"concentration = 0.02; a = 4; b = 0.1 logistic(concentration, a, b) #> [1] 0.9820491"},{"path":"/reference/non_monotonic.html","id":null,"dir":"Reference","previous_headings":"","what":"non monotonic logic/boolean function — non_monotonic","title":"non monotonic logic/boolean function — non_monotonic","text":"non monotonic logic/boolean function","code":""},{"path":"/reference/non_monotonic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"non monotonic logic/boolean function — non_monotonic","text":"","code":"non_monotonic(x)"},{"path":"/reference/non_monotonic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"non monotonic logic/boolean function — non_monotonic","text":"x numeric vector, sample, number wells surviving cells per dilution","code":""},{"path":"/reference/non_monotonic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"non monotonic logic/boolean function — non_monotonic","text":"boolean '1' non-monotonic '0' monotonic","code":""},{"path":"/reference/non_monotonic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"non monotonic logic/boolean function — non_monotonic","text":"","code":"x <- c(2,2,2,2,2,0,0,0) non_monotonic(x) #> [1] 0"},{"path":"/reference/optimizing_stan.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Stan model to the simulated data — optimizing_stan","title":"Fit a Stan model to the simulated data — optimizing_stan","text":"Fit Stan model simulated data","code":""},{"path":"/reference/optimizing_stan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Stan model to the simulated data — optimizing_stan","text":"","code":"optimizing_stan(standata, ...)"},{"path":"/reference/optimizing_stan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Stan model to the simulated data — optimizing_stan","text":"standata dataframe constructing Stan input data ... Arguments passed 'rstan::sampling' e.g., iter, chains","code":""},{"path":"/reference/optimizing_stan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Stan model to the simulated data — optimizing_stan","text":"object class 'stanfit'","code":""},{"path":"/reference/optimizing_stan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Stan model to the simulated data — optimizing_stan","text":"","code":"ndraws = 30; a = 8.5; b = 2.5; prior_phi <- list(lower = 1.75, upper = 16) dilutions <- 2^c(3, 4, 5, 6, 7, 8, 9, 10); nreplicates_per_dilution = 2 simData <- sample_dose_response(ndraws, prior_phi, a, b, dilutions, nreplicates_per_dilution)  stan_data = list(N = nrow(simData), nreplicates = rep(nreplicates_per_dilution, nrow(simData)), survival = simData$number_surviving, dilution = simData$dilution, nsample = max(simData$draw), sample = simData$draw, is_log = 1)  fit <- sampling_stan(standata = stan_data, iter = 100, init = 'random') #>  #> SAMPLING FOR MODEL 'modelwithppc' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.000113 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 1.13 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: There aren't enough warmup iterations to fit the #> Chain 1:          three stages of adaptation as currently configured. #> Chain 1:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 1:          the given number of warmup iterations: #> Chain 1:            init_buffer = 7 #> Chain 1:            adapt_window = 38 #> Chain 1:            term_buffer = 5 #> Chain 1:  #> Chain 1: Iteration:  1 / 100 [  1%]  (Warmup) #> Chain 1: Iteration: 10 / 100 [ 10%]  (Warmup) #> Chain 1: Iteration: 20 / 100 [ 20%]  (Warmup) #> Chain 1: Iteration: 30 / 100 [ 30%]  (Warmup) #> Chain 1: Iteration: 40 / 100 [ 40%]  (Warmup) #> Chain 1: Iteration: 50 / 100 [ 50%]  (Warmup) #> Chain 1: Iteration: 51 / 100 [ 51%]  (Sampling) #> Chain 1: Iteration: 60 / 100 [ 60%]  (Sampling) #> Chain 1: Iteration: 70 / 100 [ 70%]  (Sampling) #> Chain 1: Iteration: 80 / 100 [ 80%]  (Sampling) #> Chain 1: Iteration: 90 / 100 [ 90%]  (Sampling) #> Chain 1: Iteration: 100 / 100 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.047958 seconds (Warm-up) #> Chain 1:                0.035691 seconds (Sampling) #> Chain 1:                0.083649 seconds (Total) #> Chain 1:  #>  #> SAMPLING FOR MODEL 'modelwithppc' NOW (CHAIN 2). #> Chain 2:  #> Chain 2: Gradient evaluation took 7.6e-05 seconds #> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.76 seconds. #> Chain 2: Adjust your expectations accordingly! #> Chain 2:  #> Chain 2:  #> Chain 2: WARNING: There aren't enough warmup iterations to fit the #> Chain 2:          three stages of adaptation as currently configured. #> Chain 2:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 2:          the given number of warmup iterations: #> Chain 2:            init_buffer = 7 #> Chain 2:            adapt_window = 38 #> Chain 2:            term_buffer = 5 #> Chain 2:  #> Chain 2: Iteration:  1 / 100 [  1%]  (Warmup) #> Chain 2: Iteration: 10 / 100 [ 10%]  (Warmup) #> Chain 2: Iteration: 20 / 100 [ 20%]  (Warmup) #> Chain 2: Iteration: 30 / 100 [ 30%]  (Warmup) #> Chain 2: Iteration: 40 / 100 [ 40%]  (Warmup) #> Chain 2: Iteration: 50 / 100 [ 50%]  (Warmup) #> Chain 2: Iteration: 51 / 100 [ 51%]  (Sampling) #> Chain 2: Iteration: 60 / 100 [ 60%]  (Sampling) #> Chain 2: Iteration: 70 / 100 [ 70%]  (Sampling) #> Chain 2: Iteration: 80 / 100 [ 80%]  (Sampling) #> Chain 2: Iteration: 90 / 100 [ 90%]  (Sampling) #> Chain 2: Iteration: 100 / 100 [100%]  (Sampling) #> Chain 2:  #> Chain 2:  Elapsed Time: 0.053241 seconds (Warm-up) #> Chain 2:                0.031258 seconds (Sampling) #> Chain 2:                0.084499 seconds (Total) #> Chain 2:  #>  #> SAMPLING FOR MODEL 'modelwithppc' NOW (CHAIN 3). #> Chain 3:  #> Chain 3: Gradient evaluation took 7.5e-05 seconds #> Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.75 seconds. #> Chain 3: Adjust your expectations accordingly! #> Chain 3:  #> Chain 3:  #> Chain 3: WARNING: There aren't enough warmup iterations to fit the #> Chain 3:          three stages of adaptation as currently configured. #> Chain 3:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 3:          the given number of warmup iterations: #> Chain 3:            init_buffer = 7 #> Chain 3:            adapt_window = 38 #> Chain 3:            term_buffer = 5 #> Chain 3:  #> Chain 3: Iteration:  1 / 100 [  1%]  (Warmup) #> Chain 3: Iteration: 10 / 100 [ 10%]  (Warmup) #> Chain 3: Iteration: 20 / 100 [ 20%]  (Warmup) #> Chain 3: Iteration: 30 / 100 [ 30%]  (Warmup) #> Chain 3: Iteration: 40 / 100 [ 40%]  (Warmup) #> Chain 3: Iteration: 50 / 100 [ 50%]  (Warmup) #> Chain 3: Iteration: 51 / 100 [ 51%]  (Sampling) #> Chain 3: Iteration: 60 / 100 [ 60%]  (Sampling) #> Chain 3: Iteration: 70 / 100 [ 70%]  (Sampling) #> Chain 3: Iteration: 80 / 100 [ 80%]  (Sampling) #> Chain 3: Iteration: 90 / 100 [ 90%]  (Sampling) #> Chain 3: Iteration: 100 / 100 [100%]  (Sampling) #> Chain 3:  #> Chain 3:  Elapsed Time: 0.069929 seconds (Warm-up) #> Chain 3:                0.045034 seconds (Sampling) #> Chain 3:                0.114963 seconds (Total) #> Chain 3:  #>  #> SAMPLING FOR MODEL 'modelwithppc' NOW (CHAIN 4). #> Chain 4:  #> Chain 4: Gradient evaluation took 6.9e-05 seconds #> Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.69 seconds. #> Chain 4: Adjust your expectations accordingly! #> Chain 4:  #> Chain 4:  #> Chain 4: WARNING: There aren't enough warmup iterations to fit the #> Chain 4:          three stages of adaptation as currently configured. #> Chain 4:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 4:          the given number of warmup iterations: #> Chain 4:            init_buffer = 7 #> Chain 4:            adapt_window = 38 #> Chain 4:            term_buffer = 5 #> Chain 4:  #> Chain 4: Iteration:  1 / 100 [  1%]  (Warmup) #> Chain 4: Iteration: 10 / 100 [ 10%]  (Warmup) #> Chain 4: Iteration: 20 / 100 [ 20%]  (Warmup) #> Chain 4: Iteration: 30 / 100 [ 30%]  (Warmup) #> Chain 4: Iteration: 40 / 100 [ 40%]  (Warmup) #> Chain 4: Iteration: 50 / 100 [ 50%]  (Warmup) #> Chain 4: Iteration: 51 / 100 [ 51%]  (Sampling) #> Chain 4: Iteration: 60 / 100 [ 60%]  (Sampling) #> Chain 4: Iteration: 70 / 100 [ 70%]  (Sampling) #> Chain 4: Iteration: 80 / 100 [ 80%]  (Sampling) #> Chain 4: Iteration: 90 / 100 [ 90%]  (Sampling) #> Chain 4: Iteration: 100 / 100 [100%]  (Sampling) #> Chain 4:  #> Chain 4:  Elapsed Time: 0.169084 seconds (Warm-up) #> Chain 4:                0.126374 seconds (Sampling) #> Chain 4:                0.295458 seconds (Total) #> Chain 4:  #> Warning: There were 122 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems #> Warning: The largest R-hat is NA, indicating chains have not mixed. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#r-hat #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess #> Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess"},{"path":"/reference/reedmuenchTitrations.html","id":null,"dir":"Reference","previous_headings":"","what":"Reed and Muench titration data. — reedmuenchTitrations","title":"Reed and Muench titration data. — reedmuenchTitrations","text":"dataset containing serum titration data published Reed Muench paper, 1938.","code":""},{"path":"/reference/reedmuenchTitrations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reed and Muench titration data. — reedmuenchTitrations","text":"","code":"reedmuenchTitrations"},{"path":"/reference/reedmuenchTitrations.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Reed and Muench titration data. — reedmuenchTitrations","text":"data frame 9 rows 4 variables dilution serum dilution Alive Number animals surviving Dead Number animals dead Survival Percentage surviving dilution","code":""},{"path":"/reference/reedmuenchTitrations.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Reed and Muench titration data. — reedmuenchTitrations","text":"Simple Method Estimating Fifty Per Cent Endpoints, American Journal Hygiene, 1938","code":""},{"path":"/reference/sample_dose_response.html","id":null,"dir":"Reference","previous_headings":"","what":"simulate data that has sample dose response — sample_dose_response","title":"simulate data that has sample dose response — sample_dose_response","text":"simulate data sample dose response","code":""},{"path":"/reference/sample_dose_response.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"simulate data that has sample dose response — sample_dose_response","text":"","code":"sample_dose_response(   ndraws,   prior_phi,   a,   b,   dilutions,   nreplicates_per_dilution )"},{"path":"/reference/sample_dose_response.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"simulate data that has sample dose response — sample_dose_response","text":"ndraws numeric value number draws simulations prior_phi list numeric values boundaries uniform distribution Numeric value estimated model b Numeric value estimated model dilutions Numeric value number dilutions per sample nreplicates_per_dilution Numeric value","code":""},{"path":"/reference/sample_dose_response.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"simulate data that has sample dose response — sample_dose_response","text":"dataframe simulated data","code":""},{"path":"/reference/sample_dose_response.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"simulate data that has sample dose response — sample_dose_response","text":"","code":"ndraws = 30; a = 8.5; b = 2.5; prior_phi <- list(lower = 0.75, upper = 16); dilutions <- 2^c(3, 4, 5, 6, 7, 8, 9, 10); nreplicates_per_dilution = 2 simData <- sample_dose_response(ndraws, prior_phi, a, b, dilutions, nreplicates_per_dilution)"},{"path":"/reference/sampling_rm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Stan model to the Reed and Muench data (reedmuenchTitrations) — sampling_rm","title":"Fit a Stan model to the Reed and Muench data (reedmuenchTitrations) — sampling_rm","text":"Fit Stan model Reed Muench data (reedmuenchTitrations)","code":""},{"path":"/reference/sampling_rm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Stan model to the Reed and Muench data (reedmuenchTitrations) — sampling_rm","text":"","code":"sampling_rm(standata, ...)"},{"path":"/reference/sampling_rm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Stan model to the Reed and Muench data (reedmuenchTitrations) — sampling_rm","text":"standata dataframe constructing Stan input data ... Arguments passed 'rstan::sampling' e.g., iter, chains","code":""},{"path":"/reference/sampling_rm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Stan model to the Reed and Muench data (reedmuenchTitrations) — sampling_rm","text":"object class 'stanfit'","code":""},{"path":"/reference/sampling_stan.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Stan model to the simulated data — sampling_stan","title":"Fit a Stan model to the simulated data — sampling_stan","text":"Fit Stan model simulated data","code":""},{"path":"/reference/sampling_stan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Stan model to the simulated data — sampling_stan","text":"","code":"sampling_stan(standata, ...)"},{"path":"/reference/sampling_stan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Stan model to the simulated data — sampling_stan","text":"standata dataframe constructing Stan input data ... Arguments passed 'rstan::sampling' e.g., iter, chains","code":""},{"path":"/reference/sampling_stan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Stan model to the simulated data — sampling_stan","text":"object class 'stanfit'","code":""},{"path":"/reference/sampling_stan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Stan model to the simulated data — sampling_stan","text":"","code":"ndraws = 30; a = 8.5; b = 2.5; prior_phi <- list(lower = 1.75, upper = 16) dilutions <- 2^c(3, 4, 5, 6, 7, 8, 9, 10); nreplicates_per_dilution = 2 simData <- sample_dose_response(ndraws, prior_phi, a, b, dilutions, nreplicates_per_dilution)  stan_data = list(N = nrow(simData), nreplicates = rep(nreplicates_per_dilution, nrow(simData)), survival = simData$number_surviving, dilution = simData$dilution, nsample = max(simData$draw), sample = simData$draw, is_log = 1)  fit <- sampling_stan(standata = stan_data, iter = 100, chains = 1, init = 'random') #>  #> SAMPLING FOR MODEL 'modelwithppc' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 8.6e-05 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.86 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: There aren't enough warmup iterations to fit the #> Chain 1:          three stages of adaptation as currently configured. #> Chain 1:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 1:          the given number of warmup iterations: #> Chain 1:            init_buffer = 7 #> Chain 1:            adapt_window = 38 #> Chain 1:            term_buffer = 5 #> Chain 1:  #> Chain 1: Iteration:  1 / 100 [  1%]  (Warmup) #> Chain 1: Iteration: 10 / 100 [ 10%]  (Warmup) #> Chain 1: Iteration: 20 / 100 [ 20%]  (Warmup) #> Chain 1: Iteration: 30 / 100 [ 30%]  (Warmup) #> Chain 1: Iteration: 40 / 100 [ 40%]  (Warmup) #> Chain 1: Iteration: 50 / 100 [ 50%]  (Warmup) #> Chain 1: Iteration: 51 / 100 [ 51%]  (Sampling) #> Chain 1: Iteration: 60 / 100 [ 60%]  (Sampling) #> Chain 1: Iteration: 70 / 100 [ 70%]  (Sampling) #> Chain 1: Iteration: 80 / 100 [ 80%]  (Sampling) #> Chain 1: Iteration: 90 / 100 [ 90%]  (Sampling) #> Chain 1: Iteration: 100 / 100 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.05832 seconds (Warm-up) #> Chain 1:                0.027335 seconds (Sampling) #> Chain 1:                0.085655 seconds (Total) #> Chain 1:  #> Warning: There were 42 divergent transitions after warmup. See #> https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup #> to find out why this is a problem and how to eliminate them. #> Warning: Examine the pairs() plot to diagnose sampling problems #> Warning: The largest R-hat is NA, indicating chains have not mixed. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#r-hat #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess #> Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess"},{"path":"/reference/simulate_cell_survival.html","id":null,"dir":"Reference","previous_headings":"","what":"simulation functions — simulate_cell_survival","title":"simulation functions — simulate_cell_survival","text":"simulation functions","code":""},{"path":"/reference/simulate_cell_survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"simulation functions — simulate_cell_survival","text":"","code":"simulate_cell_survival(dilution, phi, a, b, nreplicates)"},{"path":"/reference/simulate_cell_survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"simulation functions — simulate_cell_survival","text":"dilution Numeric value 8, 16, 32, 64, 128, 256, 512, 1024. phi Model estimate. Model estimate. b Model estimate. nreplicates Fixed value 2.","code":""},{"path":"/reference/simulate_cell_survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"simulation functions — simulate_cell_survival","text":"numeric value","code":""},{"path":"/reference/simulate_cell_survival.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"simulation functions — simulate_cell_survival","text":"","code":"dilution = 16; phi = 42; a = 4; b = 1.2; nreplicates = 2 simulate_cell_survival(dilution, phi, a, b, nreplicates) #> [1] 2"},{"path":"/reference/simulate_dose_response.html","id":null,"dir":"Reference","previous_headings":"","what":"simulation function — simulate_dose_response","title":"simulation function — simulate_dose_response","text":"simulation function","code":""},{"path":"/reference/simulate_dose_response.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"simulation function — simulate_dose_response","text":"","code":"simulate_dose_response(dilutions, phi, a, b, nreplicates)"},{"path":"/reference/simulate_dose_response.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"simulation function — simulate_dose_response","text":"dilutions Numeric vector 8, 16, 32, 64, 128, 256, 512, 1024. phi Model estimate. Model estimate. b Model estimate. nreplicates Fixed value 2.","code":""},{"path":"/reference/simulate_dose_response.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"simulation function — simulate_dose_response","text":"numeric vector length 8","code":""},{"path":"/reference/simulate_dose_response.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"simulation function — simulate_dose_response","text":"","code":"dilutions <- vector() for(i in 3:10){j <- 2^i; dilutions <- c(dilutions, j)}; phi = 42; a = 4; b = 1.2; nreplicates = 2 simulate_dose_response(dilutions, phi, a, b, nreplicates) #> # A tibble: 8 × 3 #>   dilution number_surviving number_replicates #>      <dbl>            <int>             <dbl> #> 1        8                2                 2 #> 2       16                2                 2 #> 3       32                2                 2 #> 4       64                2                 2 #> 5      128                2                 2 #> 6      256                2                 2 #> 7      512                2                 2 #> 8     1024                2                 2"}]
