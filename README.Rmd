---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-"
)
```

# bayesianTiterCalc

<!-- badges: start -->
[![R-CMD-check.yaml](https://github.com/ekamau/bayesianTiterCalc/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/ekamau/bayesianTiterCalc/actions)
[![R-CMD-check](https://github.com/ekamau/bayesianTiterCalc/workflows/R-CMD-check/badge.svg)](https://github.com/ekamau/bayesianTiterCalc/actions)
[![codecov](https://codecov.io/gh/ekamau/bayesianTiterCalc/branch/master/graph/badge.svg?token=61D5K98II1)](https://codecov.io/gh/ekamau/bayesianTiterCalc)
<!-- badges: end -->

bayesianTiterCalc is a Bayesian inference method that calculates a serum sample's antibody concentration, $\phi$, and titer based on data from a standard neutralization assay. The method uses a logistic function in a statistical model to simulate mortality in cell culture as a function of antibody concentration. <br>
Given the limited information per sample that's inherent in the experimental design of neutralization assays (number of replicates per dilution and number of dilutions), the advantage of Bayesian inference here is the use of probability distributions to incorporate uncertainty in the outcome.


## Installation

You can install the development version of bayesianTiterCalc from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("ekamau/bayesianTiterCalc")
```

## Usage

Example of data simulation: 30 samples tested at two replicates per dilution point and with $\phi$ values sampled from a uniform distribution between 1.75 and 16.

```{r, results = 'hide'}
library(bayesianTiterCalc)

ndraws = 30; a = 4.5; b = 1.5; prior_phi <- list(lower = 1.75, upper = 16)
dilutions <- 2^c(3, 4, 5, 6, 7, 8, 9, 10); nreplicates_per_dilution = 2
simData <- sample_dose_response(ndraws, prior_phi, a, b, dilutions, nreplicates_per_dilution)
head(simData)
table(simData$number_surviving)

```

Plot four simulated samples to visualize the number of replicates per dilution with surviving cells:

```{r, message=FALSE, warning=FALSE, out.width='60%', out.height='40%', dpi=300}
library(tidyverse)

simData %>%
  filter(.data$draw %in% 1:4) %>%
  group_by(.data$draw, .data$dilution) %>%
  summarise(outcome = .data$number_surviving) %>%
  ggplot(aes(x = .data$dilution, y = .data$outcome)) +
    geom_point() +
    scale_x_log10() +
    ylim(0, 2) +
    labs(x = 'Dilution', y = 'Outcome') +
    theme(axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          strip.text = element_text(size = 12)) +
    facet_wrap(~ .data$draw)

```

Check if simulated data is non monotonic, i.e., mortality of cell cultures increases with higher serum dilutions. Non-monotonic data would show 'accidental' death or survival of cell cultures in between dilution levels. In the *table* output, '0' and '1' represents monotonic and non-monotonic data points, respectively.

```{r }
non_monotone <- simData %>%
  group_by(simData$draw) %>%
  summarise(is_non_monotone = non_monotonic(simData$number_surviving))

table(non_monotone$is_non_monotone)

```

Model fitting:

```{r, warning = FALSE, results = 'hide'}
stan_data = list(N = nrow(simData),
                 nreplicates = rep(nreplicates_per_dilution, nrow(simData)),
                 survival = simData$number_surviving,
                 dilution = simData$dilution,
                 nsample = max(simData$draw),
                 sample = simData$draw,
                 is_log = 1)

fit <- sampling_stan(standata = stan_data, chains=4, iter = 1000, init = 'random')

```

Summarize the model fitted data and plot:

``` {r, results = 'hide', message=FALSE, warning=FALSE, out.width='60%', out.height='30%', dpi=300}
library(ggplot2)

# Compare phi values - in the simulated ('actual') data and those estimated by the model:
phis <- apply(rstan::extract(fit, "phi")[[1]], 2, mean)
phiEstimated <- data.frame('phi' = phis, 'dataset' = rep('Estimated', length(phis)))
head(simData)
phiVals <- (simData[!duplicated(simData[,c('draw')]),'phiValue'])$phiValue
phiSimulated <- data.frame('phi' = phiVals, 'dataset' = rep('Simulated', length(phiVals)))
phiDF <- rbind(phiEstimated, phiSimulated)
head(phiDF)

ggplot(phiDF, aes(phi, fill = dataset)) +
  geom_density(alpha = 0.3) +
  scale_fill_brewer(palette = 'Set1') +
  labs(x = 'phi', y = '') +
  theme_bw() +
  theme(axis.title = element_text(size = 12),
        axis.text = element_text(size = 10))

```

